<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Construction Reference - UK Property Types</title>
<style>
  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    max-width: 1200px;
    margin: 20px auto;
    padding: 20px;
    background: #f5f5f5;
  }
  
  h1 {
    color: #333;
    border-bottom: 3px solid #667eea;
    padding-bottom: 10px;
  }
  
  h2 {
    color: #667eea;
    margin-top: 30px;
  }
  
  .property-section {
    background: white;
    padding: 20px;
    margin-bottom: 20px;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  }
  
  .property-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 15px;
    padding-bottom: 10px;
    border-bottom: 2px solid #e0e0e0;
  }
  
  .property-name {
    font-size: 20px;
    font-weight: 700;
    color: #333;
  }
  
  .property-era {
    font-size: 14px;
    color: #666;
    font-style: italic;
  }
  
  table {
    width: 100%;
    border-collapse: collapse;
    margin: 10px 0;
  }
  
  th {
    background: #f5f5f5;
    text-align: left;
    padding: 10px;
    font-weight: 600;
    border-bottom: 2px solid #ddd;
  }
  
  td {
    padding: 10px;
    border-bottom: 1px solid #eee;
  }
  
  .element-type {
    font-weight: 600;
    color: #667eea;
  }
  
  .uvalue {
    font-weight: 700;
    color: #333;
  }
  
  .uvalue.good {
    color: #4CAF50;
  }
  
  .uvalue.poor {
    color: #f44336;
  }
  
  .uvalue.medium {
    color: #ff9800;
  }
  
  .materials-section {
    background: #e8f5e9;
    padding: 20px;
    border-radius: 8px;
    margin-top: 30px;
  }
  
  .material-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    gap: 15px;
    margin-top: 15px;
  }
  
  .material-card {
    background: white;
    padding: 15px;
    border-radius: 6px;
    border-left: 4px solid #4CAF50;
  }
  
  .material-name {
    font-weight: 700;
    color: #333;
    margin-bottom: 5px;
  }
  
  .material-type {
    font-size: 12px;
    color: #999;
    text-transform: uppercase;
    margin-bottom: 5px;
  }
  
  .material-uvalue {
    font-size: 18px;
    font-weight: 700;
    color: #4CAF50;
  }
  
  .material-desc {
    font-size: 12px;
    color: #666;
    margin-top: 5px;
  }
  
  .material-card.poor {
    border-left-color: #f44336;
  }
  
  .material-card.poor .material-uvalue {
    color: #f44336;
  }
  
  .material-card.medium {
    border-left-color: #ff9800;
  }
  
  .material-card.medium .material-uvalue {
    color: #ff9800;
  }
</style>
</head>
<body>

<h1>üè† UK Property Construction Reference</h1>
<p style="color: #666; font-style: italic;">Data sourced from propertyTemplates.js - Single source of truth</p>

<div id="propertiesContainer"></div>

<h2>üìä Standard Construction Materials</h2>

<div class="materials-section">
  <h3>Wall Construction Types</h3>
  <div id="wallMaterials" class="material-grid"></div>
  
  <h3 style="margin-top: 30px;">Floor Construction Types</h3>
  <div id="floorMaterials" class="material-grid"></div>
  
  <h3 style="margin-top: 30px;">Roof Construction Types</h3>
  <div id="roofMaterials" class="material-grid"></div>
  
  <h3 style="margin-top: 30px;">Window Types</h3>
  <div id="windowMaterials" class="material-grid"></div>
</div>

<script type="module">
import { PROPERTY_TEMPLATES, getAllTemplateIds } from './propertyTemplates.js';

// Helper to determine U-value quality class
function getUValueClass(uValue) {
  if (uValue === 0) return '';
  if (uValue <= 0.3) return 'good';
  if (uValue <= 1.0) return 'medium';
  return 'poor';
}

// Helper to format thickness
function formatThickness(thickness) {
  return thickness ? `${thickness}m` : '-';
}

// Render property sections
function renderProperties() {
  const container = document.getElementById('propertiesContainer');
  const templateIds = getAllTemplateIds();
  
  templateIds.forEach(templateId => {
    const template = PROPERTY_TEMPLATES[templateId];
    
    const section = document.createElement('div');
    section.className = 'property-section';
    
    let html = `
      <div class="property-header">
        <span class="property-name">${template.name}</span>
        <span class="property-era">${template.era}</span>
      </div>
      
      <table>
        <tr>
          <th>Element</th>
          <th>Type</th>
          <th>Thickness</th>
          <th>U-Value (W/m¬≤K)</th>
        </tr>
    `;
    
    // External walls
    html += `
      <tr>
        <td class="element-type">External Walls</td>
        <td>${template.construction.walls.external.description}</td>
        <td>${formatThickness(template.construction.walls.external.thickness)}</td>
        <td><span class="uvalue ${getUValueClass(template.construction.walls.external.uValue)}">${template.construction.walls.external.uValue.toFixed(2)}</span></td>
      </tr>
    `;
    
    // Party walls (if exists)
    if (template.construction.walls.party) {
      html += `
        <tr>
          <td class="element-type">Party Wall</td>
          <td>${template.construction.walls.party.description}</td>
          <td>${formatThickness(template.construction.walls.party.thickness)}</td>
          <td><span class="uvalue">${template.construction.walls.party.uValue.toFixed(2)}</span> ${template.construction.walls.party.uValue === 0 ? '(no heat loss)' : ''}</td>
        </tr>
      `;
    }
    
    // Internal walls
    html += `
      <tr>
        <td class="element-type">Internal Walls</td>
        <td>${template.construction.walls.internal.description}</td>
        <td>${formatThickness(template.construction.walls.internal.thickness)}</td>
        <td><span class="uvalue ${getUValueClass(template.construction.walls.internal.uValue)}">${template.construction.walls.internal.uValue.toFixed(2)}</span></td>
      </tr>
    `;
    
    // Ground floor
    html += `
      <tr>
        <td class="element-type">Ground Floor</td>
        <td>${template.construction.floor.ground.description}</td>
        <td>-</td>
        <td><span class="uvalue ${getUValueClass(template.construction.floor.ground.uValue)}">${template.construction.floor.ground.uValue.toFixed(2)}</span></td>
      </tr>
    `;
    
    // Upper floors (only if exists)
    if (template.construction.floor.upper) {
      html += `
        <tr>
          <td class="element-type">Upper Floors</td>
          <td>${template.construction.floor.upper.description}</td>
          <td>-</td>
          <td><span class="uvalue ${getUValueClass(template.construction.floor.upper.uValue)}">${template.construction.floor.upper.uValue.toFixed(2)}</span></td>
        </tr>
      `;
    }
    
    // Roof
    html += `
      <tr>
        <td class="element-type">Roof</td>
        <td>${template.construction.roof.description}</td>
        <td>-</td>
        <td><span class="uvalue ${getUValueClass(template.construction.roof.uValue)}">${template.construction.roof.uValue.toFixed(2)}</span></td>
      </tr>
    `;
    
    // Windows
    html += `
      <tr>
        <td class="element-type">Windows</td>
        <td>${template.construction.windows.description}</td>
        <td>-</td>
        <td><span class="uvalue ${getUValueClass(template.construction.windows.uValue)}">${template.construction.windows.uValue.toFixed(2)}</span></td>
      </tr>
    `;
    
    html += '</table>';
    section.innerHTML = html;
    container.appendChild(section);
  });
}

// Collect unique materials from all templates
function collectMaterials() {
  const materials = {
    walls: new Map(),
    floors: new Map(),
    roofs: new Map(),
    windows: new Map()
  };
  
  const templateIds = getAllTemplateIds();
  
  templateIds.forEach(templateId => {
    const template = PROPERTY_TEMPLATES[templateId];
    const c = template.construction;
    
    // Walls
    if (c.walls.external) {
      const key = c.walls.external.type;
      if (!materials.walls.has(key)) {
        materials.walls.set(key, {
          type: c.walls.external.type,
          uValue: c.walls.external.uValue,
          description: c.walls.external.description
        });
      }
    }
    
    if (c.walls.internal) {
      const key = c.walls.internal.type;
      if (!materials.walls.has(key)) {
        materials.walls.set(key, {
          type: c.walls.internal.type,
          uValue: c.walls.internal.uValue,
          description: c.walls.internal.description
        });
      }
    }
    
    // Floors
    if (c.floor.ground) {
      const key = c.floor.ground.type;
      if (!materials.floors.has(key)) {
        materials.floors.set(key, {
          type: c.floor.ground.type,
          uValue: c.floor.ground.uValue,
          description: c.floor.ground.description
        });
      }
    }
    
    if (c.floor.upper) {
      const key = c.floor.upper.type;
      if (!materials.floors.has(key)) {
        materials.floors.set(key, {
          type: c.floor.upper.type,
          uValue: c.floor.upper.uValue,
          description: c.floor.upper.description
        });
      }
    }
    
    // Roofs
    if (c.roof) {
      const key = c.roof.type;
      if (!materials.roofs.has(key)) {
        materials.roofs.set(key, {
          type: c.roof.type,
          uValue: c.roof.uValue,
          description: c.roof.description
        });
      }
    }
    
    // Windows
    if (c.windows) {
      const key = c.windows.type;
      if (!materials.windows.has(key)) {
        materials.windows.set(key, {
          type: c.windows.type,
          uValue: c.windows.uValue,
          description: c.windows.description
        });
      }
    }
  });
  
  return materials;
}

// Render material cards
function renderMaterials() {
  const materials = collectMaterials();
  
  // Walls
  const wallContainer = document.getElementById('wallMaterials');
  materials.walls.forEach(material => {
    const card = createMaterialCard('Wall', material);
    wallContainer.appendChild(card);
  });
  
  // Floors
  const floorContainer = document.getElementById('floorMaterials');
  materials.floors.forEach(material => {
    const card = createMaterialCard('Floor', material);
    floorContainer.appendChild(card);
  });
  
  // Roofs
  const roofContainer = document.getElementById('roofMaterials');
  materials.roofs.forEach(material => {
    const card = createMaterialCard('Roof', material);
    roofContainer.appendChild(card);
  });
  
  // Windows
  const windowContainer = document.getElementById('windowMaterials');
  materials.windows.forEach(material => {
    const card = createMaterialCard('Window', material);
    windowContainer.appendChild(card);
  });
}

function createMaterialCard(category, material) {
  const card = document.createElement('div');
  const qualityClass = getUValueClass(material.uValue);
  card.className = `material-card ${qualityClass}`;
  
  // Format type name (replace underscores, capitalize)
  const formattedType = material.type
    .split('_')
    .map(word => word.charAt(0).toUpperCase() + word.slice(1))
    .join(' ');
  
  card.innerHTML = `
    <div class="material-type">${category}</div>
    <div class="material-name">${formattedType}</div>
    <div class="material-uvalue">${material.uValue.toFixed(2)} W/m¬≤K</div>
    <div class="material-desc">${material.description}</div>
  `;
  
  return card;
}

// Initialize
renderProperties();
renderMaterials();

console.log('Construction reference loaded from propertyTemplates.js');
console.log('Total templates:', getAllTemplateIds().length);
</script>

</body>
</html>
